---
layout: post
title: Redis相关设计使用详解
date: 2018-11-05 17:22
categories: java技术
tags: 技术积累
description: 本篇文章的诞生是自身的一个想法，想写出一篇有深度便于理解的Redis的技术文章。也由于最近发现自己有很多不足，关于Redis有一些极其细节的地方还不是太了解，所以重温下Redis相关设计及原理加以总结，以提高自己的理解能力，并且学习Redis相关细节执行的原理，希望后续能够对自己使用也好、线上事故处理也好能有所帮助。

---
*****
* TOC
{:toc}
*****


# Redis设计原则

这个看了篇文章，感觉特别重要的一点是：我们所要学习的一种技术或组件，如果能够理解或抓住其核心思想，它解决问题的思路及方式，那么后续如果碰到新问题的时候才会加以灵活应用和解决。

## Redis设计原则

### 存储效率
Redis专门用于存储数据的，它对于计算机资源的主要消耗在于内存，节省内存是它的一个重要方面，所以Redis的内部数据结构设计比较精细，设计的时候考虑了数据压缩，减少内存随便等问题。

### 快速响应

### 单线程

Redis性能瓶颈不在cpu资源，一般在用内存访问和网络IO的耗时上，采用单线程设计带来的好处是：极大地简化数据结构和算法的实现。Redis通过异步IO和pipeline等机制来实现高速的并发访问。


# Redis数据结构及其内部原理
Redis设计数据结构分为两层：一层是对外使用提供的数据结构，另外一层底层数据结构。

## 对外数据结构
包括：String、List、Map(Hash)、Set、SortedSet

### String类型：

字符串、整数和浮点数。根据场景相互自动转型，并且根据需要选取底层实现承载方式。

String 类型的value内部：int、sds结构作为存储，int存放整形数据，sds存放字节、字符串和浮点类型数据。

sds内部结构：
> 用buf数组存储字符串内容，但数组长度会大于存储内容的长度。会有专门存放“\0”作为结尾，还会多预留几个空间（free区域），当append字符串长度小于free区域，则sds不会重新申请内存，直接使用free区域。

> 扩容：对当前字符串操作完成后预期小于1M时，扩容后数组buf长度=预期长度*2+1；若大于1M，则buf总会预留1M的free空间

> value对象通常分为两部分：redisObject和redisObject的ptr指向sds部分。创建value对象时，通常需要为redisObject和sds申请两次内存。但对于短小的字符串，可以把两者连续存放，所以会一次将两者内存都申请了。

### list类型

list类型value对象内部：linkedlist和ziplist作为存储。当list元素个数和单个元素长度较小时，redis会采用ziplist实现承载方式以减少内存占用，否则采用linkedlist结构。

linkedlist内部实现时双向链表。在list定义了头尾指针和列表长度，pop/push操作、llen操作时间复杂度为O(1)。由于时链表lindex操作时间复杂度是O(N)。

ziplist内部结构：

> 所有数据放置在连续内存中，其中zlbytes表示ziplist总长度，zltail指向最末元素，zllen表示元素个数，entry表示元素自身内容为ziplist界定符。

> rpush、rpop、llen复杂度为O(1)，lpush和pop操作由于涉及全列表元素移动，时间复杂度为O(N)。

以下为ziplist源码数据结构定义：

```C
typedef struct ziplist{
     /*ziplist分配的内存大小*/
     uint32_t bytes;
     /*达到尾部的偏移量*/
     uint32_t tail_offset;
     /*存储元素实体个数*/
     uint16_t length;
     /*存储内容实体元素*/
     unsigned char* content[];
     /*尾部标识*/
     unsigned char end;
}ziplist;

/*元素实体所有信息, 仅仅是描述使用, 内存中并非如此存储*/
typedef struct zlentry {
     /*前一个元素长度需要空间和前一个元素长度*/
    unsigned int prevrawlensize, prevrawlen;
     /*元素长度需要空间和元素长度*/
    unsigned int lensize, len;
     /*头部长度即prevrawlensize + lensize*/
    unsigned int headersize;
     /*元素内容编码*/
    unsigned char encoding;
     /*元素实际内容*/
    unsigned char *p;
}zlentry;
``` 
ziplist内存布局

| bytes | offset | length | content | {zlentry,zlentry ... ...} | end |
| :-----: | :-----: | :-----: | :-----: | :-----: |

### map类型
map又叫hash。map内存的key和value不能嵌套map。只能以string类型：整形、浮点和字符串。

map本身内部存储的数据结构：hashtable和ziplist两种承载方式实现。对于数据量较小的map采用ziplist实现。

hashtable的内部结构：
> 1. 主要分为三层，自底向上分别是：dictEntry、dicht、dict

> 2. dictEntry管理一个key-value对，同时保留同一个桶中相邻元素的指针，依次维护hash桶中的元素内部链

> 3. dictht是一个数组，维护hash表中的所有桶链,它的table字段维护整个hash桶，是一个数组，每个元素指向桶的第一个元素

> 4. dict,当dictht需要扩容\缩容时，用于管理dictht的迁移

> 5. set值的流程：先通过MurmurHash算法求出key的hash值，，再对桶个数取模找出key对应的桶，然后进入桶中，遍历桶中全部dictEntry，判断是否已经有相同的key，如果没有，则将新key对应的key-value键值对采用头插法放桶的头部，并更新dictht的used数量，否则更新对应的dictEntry。(used表示hash表中已存在的多少个元素)。由于每次插入都要遍历桶中的dictEntry，所以桶中dictEntry比较多的时候，性能会线性下降。

> 6. 扩容，通过负载因子判定是否需要增加桶的个数。负载因子=used元素总数/hash桶个数。有两个阈值小于1一定不扩容；大于5一定扩容。扩容时hash新桶数量=2*现有hash桶数量

> 7. 缩容：负载因子的阈值时：0.1

> 8. 扩容或缩容时通过新建hash表dictht的方式实现。即扩容时会存在两个hash表，一个源表。一个目标表。通过将源表桶逐步迁移到目标表，以数据迁移到方式实现扩容，迁移完成后目标表覆盖源表。值得注意的是：迁移过程中，key的访问首先访问源表，如果发现key对应的源表中的桶已完成迁移，则重新访问目标表，否则在源表中操作。

> 9. redis是单线程操作出来请求，迁移和访问请求都在相同的线程中进行，所以不存在并发性问题。

ziplist内部结构：
> 和list的ziplist实现类似，不同的是map对应的ziplist的entry个数总数2的整数倍

> ziplist实现下，由hash表遍历变成了链表的顺序遍历，复杂度为O(N)

### set类型

set内部结构：intset、hashtable来存储。当set中只包含整形元素时，则采用intset

hashtable存储时，hashtable中的value永远为null。

intset内部结构：
> 1. 核心元素是一个字节数组，从小到大存放set的元素。

> 2. 由于元素有序排列，所以set获取操作采用二分查找实现，时间复杂度O(log(N))。进行插入时，首先通过二分查找本次位置，然后进行扩容，再将预计插入位置之后元素移动，最后插入元素，插入时间复杂度为O(N)。删除类似。

### sorted-set类型

sorted-set内部结构类似map。一个key-value对，但是有序的，value是一个浮点数。称为score，内部按照score从小到大进行排序的。

serted-set内存结构：ziplist或skiplist+hashtable方式来承载实现的。 

## 底层数据结构
包括：dict、sds、ziplist、quicklist、skiplist

# Redis设计及实现原理

## Redis的Watch机制

## Redis的发布与订阅功能


# Redis过期Key处理策略

# Redis部署架构

# Redis持久化方式及优缺点


# 参考链接：
[http://zhangtielei.com/posts/blog-redis-dict.html](http://zhangtielei.com/posts/blog-redis-dict.html)

[https://blog.csdn.net/wuyangyang555/article/details/82152005](https://blog.csdn.net/wuyangyang555/article/details/82152005)





