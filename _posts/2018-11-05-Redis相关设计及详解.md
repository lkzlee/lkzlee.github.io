---
layout: post
title: Redis相关设计及详解
date: 2018-11-05 17:22
categories: java技术
tags: 技术积累
description: 本篇文章的诞生是自身的一个想法，想写出一篇有深度便于理解的Redis的技术文章。也由于最近发现自己有很多不足，关于Redis有一些极其细节的地方还不是太了解，所以重温下Redis相关设计及原理加以总结，以提高自己的理解能力，并且学习Redis相关细节执行的原理，希望后续能够对自己使用也好、线上事故处理也好能有所帮助。

---
*****
* TOC
{:toc}
*****


# Redis设计原则

这个看了篇文章，感觉特别重要的一点是：我们所要学习的一种技术或组件，如果能够理解或抓住其核心思想，它解决问题的思路及方式，那么后续如果碰到新问题的时候才会加以灵活应用和解决。

## Redis设计原则

### 存储效率
Redis专门用于存储数据的，它对于计算机资源的主要消耗在于内存，节省内存是它的一个重要方面，所以Redis的内部数据结构设计比较精细，设计的时候考虑了数据压缩，减少内存随便等问题。

### 快速响应

与快速响应对应的高吞吐量。Redis是用于提供在线访问的，对于单个请求的响应时间要求很高。因此，快速响应时间是比高吞吐量更重要的目标。有时候这两个目标是相互矛盾的。

### 单线程

Redis性能瓶颈不在cpu资源，一般在用内存访问和网络IO的耗时上，采用单线程设计带来的好处是：极大地简化数据结构和算法的实现。Redis通过异步IO和pipeline等机制来实现高速的并发访问。


# Redis数据结构及其内部原理
Redis设计数据结构分为两层：一层是对外使用提供的数据结构，另外一层底层数据结构。

## 对外数据结构
包括：String、List、Map(Hash)、Set、SortedSet

### String类型：

字符串、整数和浮点数。根据场景相互自动转型，并且根据需要选取底层实现承载方式。

String 类型的value内部：int、sds结构作为存储，int存放整形数据，sds存放字节、字符串和浮点类型数据。

sds内部结构：
> 用buf数组存储字符串内容，但数组长度会大于存储内容的长度。会有专门存放“\0”作为结尾，还会多预留几个空间（free区域），当append字符串长度小于free区域，则sds不会重新申请内存，直接使用free区域。

> 扩容：对当前字符串操作完成后预期小于1M时，扩容后数组buf长度=预期长度*2+1；若大于1M，则buf总会预留1M的free空间

> value对象通常分为两部分：redisObject和redisObject的ptr指向sds部分。创建value对象时，通常需要为redisObject和sds申请两次内存。但对于短小的字符串，可以把两者连续存放，所以会一次将两者内存都申请了。

### list类型

list类型value对象内部：linkedlist和ziplist作为存储。当list元素个数和单个元素长度较小时，redis会采用ziplist实现承载方式以减少内存占用，否则采用linkedlist结构。

linkedlist内部实现时双向链表。在list定义了头尾指针和列表长度，pop/push操作、llen操作时间复杂度为O(1)。由于时链表lindex操作时间复杂度是O(N)。

ziplist内部结构：

> 所有数据放置在连续内存中，其中zlbytes表示ziplist总长度，zltail指向最末元素，zllen表示元素个数，entry表示元素自身内容为ziplist界定符。

> rpush、rpop、llen复杂度为O(1)，lpush和pop操作由于涉及全列表元素移动，时间复杂度为O(N)。

以下为ziplist源码数据结构定义：

```C
typedef struct ziplist{
     /*ziplist分配的内存大小*/
     uint32_t bytes;
     /*达到尾部的偏移量*/
     uint32_t tail_offset;
     /*存储元素实体个数*/
     uint16_t length;
     /*存储内容实体元素*/
     unsigned char* content[];
     /*尾部标识*/
     unsigned char end;
}ziplist;

/*元素实体所有信息, 仅仅是描述使用, 内存中并非如此存储*/
typedef struct zlentry {
     /*前一个元素长度需要空间和前一个元素长度*/
    unsigned int prevrawlensize, prevrawlen;
     /*元素长度需要空间和元素长度*/
    unsigned int lensize, len;
     /*头部长度即prevrawlensize + lensize*/
    unsigned int headersize;
     /*元素内容编码*/
    unsigned char encoding;
     /*元素实际内容*/
    unsigned char *p;
}zlentry;
``` 
ziplist内存布局

| bytes | offset | length | content:{zlentry,zlentry ... ...} | end |

### map类型
map又叫hash。map内存的key和value不能嵌套map。只能以string类型：整形、浮点和字符串。

map本身内部存储的数据结构：hashtable和ziplist两种承载方式实现。对于数据量较小的map采用ziplist实现。

dict如下图所示：

![dict结构](/post_img/2018/redis_dict_structure.png)

hashtable的内部结构：
>1.主要分为三层，自底向上分别是：dictEntry、dicht、dict

>2.dictEntry管理一个key-value对，同时保留同一个桶中相邻元素的指针，依次维护hash桶中的元素内部链

>3.dictht是一个数组，维护hash表中的所有桶链,它的table字段维护整个hash桶，是一个数组，每个元素指向桶的第一个元素

>4.dict,当dictht需要扩容\缩容时，用于管理dictht的迁移

>5.set值的流程：先通过MurmurHash算法求出key的hash值，，再对桶个数取模找出key对应的桶，然后进入桶中，遍历桶中全部dictEntry，判断是否已经有相同的key，如果没有，则将新key对应的key-value键值对采用头插法放桶的头部，并更新dictht的used数量，否则更新对应的dictEntry。(used表示hash表中已存在的多少个元素)。由于每次插入都要遍历桶中的dictEntry，所以桶中dictEntry比较多的时候，性能会线性下降。

>6.扩容，通过负载因子判定是否需要增加桶的个数。负载因子=used元素总数/hash桶个数。有两个阈值小于1一定不扩容；大于5一定扩容。扩容时hash新桶数量=2*现有hash桶数量

>7.缩容：负载因子的阈值时：0.1

>8.扩容或缩容时通过新建hash表dictht的方式实现。即扩容时会存在两个hash表，一个源表。一个目标表。通过将源表桶逐步迁移到目标表，以数据迁移到方式实现扩容，迁移完成后目标表覆盖源表。值得注意的是：迁移过程中，key的访问首先访问源表，如果发现key对应的源表中的桶已完成迁移，则重新访问目标表，否则在源表中操作。

>9.redis是单线程操作出来请求，迁移和访问请求都在相同的线程中进行，所以不存在并发性问题。



ziplist内部结构：
>1.和list的ziplist实现类似，不同的是map对应的ziplist的entry个数总数2的整数倍

>2.ziplist实现下，由hash表遍历变成了链表的顺序遍历，复杂度为O(N)

### set类型

set内部结构：intset、hashtable来存储。当set中只包含整形元素时，则采用intset

hashtable存储时，hashtable中的value永远为null。

intset内部结构：
>1.核心元素是一个字节数组，从小到大存放set的元素。

>2.由于元素有序排列，所以set获取操作采用二分查找实现，时间复杂度O(log(N))。进行插入时，首先通过二分查找本次位置，然后进行扩容，再将预计插入位置之后元素移动，最后插入元素，插入时间复杂度为O(N)。删除类似。

### sorted-set类型

sorted-set内部结构类似map。一个key-value对，但是有序的，value是一个浮点数。称为score，内部按照score从小到大进行排序的。

serted-set内存结构：ziplist或skiplist+hashtable方式来承载实现的。 

## 底层数据结构
包括：redisObject、dict、sds、ziplist、skiplist、intset

底层的数据结构，在外部用户使用的过程中已经涉及到大部分数据结构的实现和应用。

### redisObject 类型
redisObject上文中已经提到，redis中key一般为字符串，value为redisObject结构体，其中它的成员void * ptr，可以绑定各种类型的数据，给了我们无限的可能。

```C
typedef struct redisObject {
    // 刚刚好32 bits
    // 对象的类型，字符串/列表/集合/哈希表
    unsigned type:4;
    // 未使用的两个位
    unsigned notused:2; /* Not used */
    // 编码的方式，Redis 为了节省空间，提供多种方式来保存一个数据
    // 譬如：“123456789” 会被存储为整数123456789
    unsigned encoding:4;
    // 当内存紧张，淘汰数据的时候用到
    unsigned lru:22; /* lru time (relative to server.lruclock) */
    // 引用计数
    int refcount;
    // 数据指针
    void *ptr;
} robj;
```


需要注意的是:

Redis进行内存预估的时候根据可以：key+redisObject占用大小+（sds、list、dict、intset）才更为准确。

### skiplist 类型
跳表（skiplist）是一个链表，相比一般链表，有更高的查找效率，其效率可以比拟二叉查找树。

跳表有以下性质：
>1.有很多层结构组成

>2.每一层是一个有序链表

>3.最底层包含所有元素

>4.如果一个元素出现在level i层，则它在level i之下的链表也会出现

>5.每个节点包含两个指针，一个指向同一链表的下一个元素，一个指向下面一层的元素。
 
Redis中跳表数据结构定义：

```C
// 跳表节点结构体
/* ZSETs use a specialized version of Skiplists */
typedef struct zskiplistNode {
    // 节点数据
    robj *obj;
    // 分数，游戏分数？按游戏分数排序
    double score;
    // 后驱指针
    struct zskiplistNode *backward;
    // 前驱指针数组TODO
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        // 调到下一个数据项需要走多少步，这在计算rank 的非常有帮助
        unsigned int span;
    } level[];
} zskiplistNode;

typedef struct zskiplist {
    // 跳表头尾指针
    struct zskiplistNode *header, *tail;
    // 跳表的长度
    unsigned long length;
    // 跳表的高度
    int level;
} zskiplist;
```
一般跳表和跳表搜索如下：

![跳表搜索](/post_img/2018/skiplist_struct.png)


跳表的查找过程：

1. 比如查找68，先从顶层查找先比较-1，如果小于-1直接结束，68显然大于-1，然后和20比较，比它大指针往后走；

2. 然后比较99，发现68比99小，此时指针向下，level层下一级

3. 此时比较30，发现68比30大，此时指针向右移动

4. 此时又出现了和顶层一样的情况，发现68比99小，此时指针向下，level层走向下一及

5. 此时比较68找到了该元素。

跳表的插入过程：

跳表的插入算法描述：找出每一层插入数据的位置并保存，在Redis跳表中是根据score/member的大小来决定插入位置；将新数据插入到指定位置，并调整指针，在Redis中还要调整span。[span:为从两个相邻的节点间隔了多少节点。]

![跳表搜索](/post_img/2018/skiplist_add.png)

Redis跳表插入源码：

```c
zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj) {
        // update 是插入节点所在位置的前一个节点。我们在学习链表插入的时候，需要找到插入
        // 位置的前一个节点。因为在跳表中一个节点是有多个前驱指针的，所以这里需要保存的
        // 是多个节点，而不是一个节点
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    unsigned int rank[ZSKIPLIST_MAXLEVEL];
    int i, level;
    redisAssert(!isnan(score));
    x = zsl->header;
    // 遍历skiplist 中所有的层，找到数据将要插入的位置，并保存在update 中
    for (i = zsl->level-1; i >= 0; i--) {
        /* store rank that is crossed to reach the insert position */
        rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];
        // 链表的搜索
        while (x->level[i].forward &&
            (x->level[i].forward->score < score ||
            (x->level[i].forward->score == score &&
            compareStringObjects(x->level[i].forward->obj,obj) < 0))) {
            rank[i] += x->level[i].span;
            x = x->level[i].forward;
        }
        // update[i] 记录了新数据项的前驱
        update[i] = x;
    }
    // random 一个level，是随机的
    /* we assume the key is not already inside, since we allow duplicated
    * scores, and the re-insertion of score and redis object should never
    * happen since the caller of zslInsert() should test in the hash table
    * if the element is already inside or not. */
    level = zslRandomLevel();
    // random level 比原有的zsl->level 大，需要增加skiplist 的level
    if (level > zsl->level) {
    for (i = zsl->level; i < level; i++) {
        rank[i] = 0;
        update[i] = zsl->header;
        update[i]->level[i].span = zsl->length;
        }
        zsl->level = level;
        }
    // 插入
    x = zslCreateNode(level,score,obj);
    for (i = 0; i < level; i++) {
        // 新节点项插到update[i] 的后面
        x->level[i].forward = update[i]->level[i].forward;
        update[i]->level[i].forward = x;
        /* update span covered by update[i] as x is inserted here */
        x->level[i].span = update[i]->level[i].span - (rank[0] - rank[i]);
        update[i]->level[i].span = (rank[0] - rank[i]) + 1;
    }
    // 更高的level 尚未调整span
    /* increment span for untouched levels */
    for (i = level; i < zsl->level; i++) {
    update[i]->level[i].span++;
    }
    // 调整新节点的后驱指针
    x->backward = (update[0] == zsl->header) ? NULL : update[0];
    if (x->level[0].forward)
        x->level[0].forward->backward = x;
    else
        zsl->tail = x;
    // 调整skiplist 的长度
        zsl->length++;
    return x;
}
```

跳表的删除过程：

跳表的删除和插入类型，找出每一层删除数据的前驱并保存；接着调整指针和span。

![跳表搜索](/post_img/2018/skiplist_delete.png)

Redis跳表删除源码：

```c
// x 是需要删除的节点
// update 是每一个层x 的前驱数组
/* Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank */
void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {
    int i;
    // 调整span 和forward 指针
    for (i = 0; i < zsl->level; i++) {
    if (update[i]->level[i].forward == x) {
        update[i]->level[i].span += x->level[i].span - 1;
        update[i]->level[i].forward = x->level[i].forward;
    } else {
    // update[i]->level[i].forward == NULL，只调整span
        update[i]->level[i].span -= 1;
        }
    }
    // 调整后驱指针
    if (x->level[0].forward) {
        x->level[0].forward->backward = x->backward;
    } else {
        zsl->tail = x->backward;
    }
    // 删除某一个节点后，层数level 可能降低，调整level
    while(zsl->level > 1 && zsl->header->level[zsl->level-1].forward == NULL)
        zsl->level--;
    // 调整跳表的长度
        zsl->length--;
}
```

   
### intset类型

Redis源码中intset定义如下：

```C
typedef struct intset {
// 每个整数的类型
uint32_t encoding;
// intset 长度
uint32_t length;
// 整数数组
int8_t contents[];
} intset;
```

intset本质上是一个有序、不重复、整形数组，支持不同类型的整数。contents没有制定长度，这样为了方便分配和释放内存。encoding能可以取三个值：16、32和64位整数。查找元素采用二分查找。

intset插入算法比较意思，需要插入的整数超出原有集合的范围（即内存内存不同），则升级整数类型，然后从后向前插入有序。否则进行二分查找位置index，然后移动位置index后的元素插入当前数据。


# Redis的Map的rehash详解

rehash有2种工作模式：
>lazy rehashing：在每次对dict进行操作的时候执行一个桶的的rehash
>
>active rehashing：每100ms里面使用1ms时间进行rehash。

rehashidx是下一个需要rehash的项在ht[0]中的索引，不需要rehash时值为-1.

rehash的过程时多次进行的，每次进行dictAdd、dictRepalce(在可以存在的情况下会调用dictAdd和dictFind这块相当于两次查询)、dictDelete操作时会触发一个桶的rehash。

redis中dict.c源码文件中关于rehash的核心代码：

```C
int dictRehash(dict *d, int n) {
    int empty_visits = n*10; /* Max number of empty buckets to visit. */
    /*判读是否在进行rehash，不在进行状态的话直接返回，通过rehashidx判定*/
    if (!dictIsRehashing(d)) return 0;

    while(n-- && d->ht[0].used != 0) {
        dictEntry *de, *nextde;

        /* Note that rehashidx can't overflow as we are sure there are more
         * elements because ht[0].used != 0 */
        assert(d->ht[0].size > (unsigned long)d->rehashidx);
        
        /*对于ht[0].table桶为空的直接跳过，rehashidx++*/
        
        while(d->ht[0].table[d->rehashidx] == NULL) {
            d->rehashidx++;
            if (--empty_visits == 0) return 1;
        }
        /*获得本次需要进行rehash桶的位置，rehashidx记录桶进度*/
        
        de = d->ht[0].table[d->rehashidx];
        /* Move all the keys in this bucket from the old to the new hash HT */
        while(de) {
            uint64_t h;

			  
            nextde = de->next;
            /* 算出源表ht[0].table中对应key到目标表ht[1].table的桶位置 */
            h = dictHashKey(d, de->key) & d->ht[1].sizemask;
            /*利用头插法进行插入，ht[0].used--,ht[1].used++*/
            de->next = d->ht[1].table[h];
            d->ht[1].table[h] = de;
            d->ht[0].used--;
            d->ht[1].used++;
            de = nextde;
        }
        d->ht[0].table[d->rehashidx] = NULL;
        d->rehashidx++;
    }

    /* 判断整个ht[1]是否迁移完成，ht[1]覆盖到ht[0],释放无用空间，rehashidx值为-1，rehash过程结束*/
    if (d->ht[0].used == 0) {
        zfree(d->ht[0].table);
        d->ht[0] = d->ht[1];
        _dictReset(&d->ht[1]);
        d->rehashidx = -1;
        return 0;
    }

    /* More to rehash... */
    return 1;
}

```

# Redis设计及实现原理

## Redis的Watch机制

## Redis的发布与订阅功能


# Redis过期Key处理策略

# Redis部署架构
Redis部署分为：单机部署，哨兵+主-从、集群模式（redis-cluster）方式

单机部署：这个很好理解，是一个单节点服务，主要用在业务不重要，数据可丢失

# Redis持久化方式及优缺点
Redis持久化方式有两种：RDB和AOF(Append of file)两种持久化方式，两种持久化方式各有优缺点。

RDB：


# 参考链接：
[http://zhangtielei.com/posts/blog-redis-dict.html](http://zhangtielei.com/posts/blog-redis-dict.html)

[https://blog.csdn.net/wuyangyang555/article/details/82152005](https://blog.csdn.net/wuyangyang555/article/details/82152005)





